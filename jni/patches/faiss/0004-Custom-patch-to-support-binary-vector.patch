From 084843c17d1ac2b36e4f8f30bce1f55b7fc0aa20 Mon Sep 17 00:00:00 2001
From: Heemin Kim <heemin@amazon.com>
Date: Fri, 1 Aug 2025 17:38:26 -0700
Subject: [PATCH] [PATCH] 0004-Custom-patch-to-support-binary-vector

Signed-off-by: Heemin Kim <heemin@amazon.com>
---
 faiss/IndexBinaryHNSW.cpp | 62 +++++++++++++++++++++++++++------------
 faiss/IndexBinaryIVF.cpp  | 28 ++++++++++++++----
 2 files changed, 65 insertions(+), 25 deletions(-)

diff --git a/faiss/IndexBinaryHNSW.cpp b/faiss/IndexBinaryHNSW.cpp
index 41f68c126..02646a8fd 100644
--- a/faiss/IndexBinaryHNSW.cpp
+++ b/faiss/IndexBinaryHNSW.cpp
@@ -200,6 +200,40 @@ void IndexBinaryHNSW::train(idx_t n, const uint8_t* x) {
     is_trained = true;
 }
 
+namespace {
+template <class BlockResultHandler>
+void hnsw_search(
+        const IndexBinaryHNSW* index,
+        idx_t n,
+        const uint8_t* x,
+        BlockResultHandler& bres,
+        const SearchParameters* params_in) {
+    const SearchParametersHNSW* params = nullptr;
+    const HNSW& hnsw = index->hnsw;
+
+    if (params_in) {
+        params = dynamic_cast<const SearchParametersHNSW*>(params_in);
+        FAISS_THROW_IF_NOT_MSG(params, "params type invalid");
+    }
+#pragma omp parallel
+    {
+        VisitedTable vt(index->ntotal);
+        std::unique_ptr<DistanceComputer> dis(index->get_distance_computer());
+        typename BlockResultHandler::SingleResultHandler res(bres);
+
+#pragma omp for
+        for (idx_t i = 0; i < n; i++) {
+            res.begin(i);
+            dis->set_query((float*)(x + i * index->code_size));
+            hnsw.search(*dis, res, vt, params);
+            res.end();
+        }
+    }
+}
+
+} // anonymous namespace
+
+
 void IndexBinaryHNSW::train(idx_t n, const void* x, NumericType numeric_type) {
     IndexBinary::train(n, x, numeric_type);
 }
@@ -210,31 +244,21 @@ void IndexBinaryHNSW::search(
         idx_t k,
         int32_t* distances,
         idx_t* labels,
-        const SearchParameters* params) const {
-    FAISS_THROW_IF_NOT_MSG(
-            !params, "search params not supported for this index");
+        const SearchParameters* params_in) const {
     FAISS_THROW_IF_NOT(k > 0);
 
     // we use the buffer for distances as float but convert them back
     // to int in the end
     float* distances_f = (float*)distances;
 
-    using RH = HeapBlockResultHandler<HNSW::C>;
-    RH bres(n, distances_f, labels, k);
-
-#pragma omp parallel
-    {
-        VisitedTable vt(ntotal);
-        std::unique_ptr<DistanceComputer> dis(get_distance_computer());
-        RH::SingleResultHandler res(bres);
-
-#pragma omp for
-        for (idx_t i = 0; i < n; i++) {
-            res.begin(i);
-            dis->set_query((float*)(x + i * code_size));
-            hnsw.search(*dis, res, vt);
-            res.end();
-        }
+    if (params_in && params_in->grp) {
+        using RH = GroupedHeapBlockResultHandler<HNSW::C>;
+        RH bres(n, distances_f, labels, k, params_in->grp);
+        hnsw_search(this, n, x, bres, params_in);
+    } else {
+        using RH = HeapBlockResultHandler<HNSW::C>;
+        RH bres(n, distances_f, labels, k);
+        hnsw_search(this, n, x, bres, params_in);
     }
 
 #pragma omp parallel for
diff --git a/faiss/IndexBinaryIVF.cpp b/faiss/IndexBinaryIVF.cpp
index b0edf0914..604f91385 100644
--- a/faiss/IndexBinaryIVF.cpp
+++ b/faiss/IndexBinaryIVF.cpp
@@ -120,25 +120,41 @@ void IndexBinaryIVF::search(
         idx_t k,
         int32_t* distances,
         idx_t* labels,
-        const SearchParameters* params) const {
-    FAISS_THROW_IF_NOT_MSG(
-            !params, "search params not supported for this index");
+        const SearchParameters* params_in) const {
     FAISS_THROW_IF_NOT(k > 0);
+    const IVFSearchParameters* params = nullptr;
+    if (params_in) {
+        params = dynamic_cast<const IVFSearchParameters*>(params_in);
+        FAISS_THROW_IF_NOT_MSG(params, "IndexIVF params have incorrect type");
+    }
+    const size_t nprobe_2 = std::min(nlist, params ? params->nprobe : this->nprobe);
     FAISS_THROW_IF_NOT(nprobe > 0);
 
-    const size_t nprobe_2 = std::min(nlist, this->nprobe);
     std::unique_ptr<idx_t[]> idx(new idx_t[n * nprobe_2]);
     std::unique_ptr<int32_t[]> coarse_dis(new int32_t[n * nprobe_2]);
 
     double t0 = getmillisecs();
-    quantizer->search(n, x, nprobe_2, coarse_dis.get(), idx.get());
+    quantizer->search(
+            n,
+            x,
+            nprobe_2,
+            coarse_dis.get(),
+            idx.get(),
+            params ? params->quantizer_params : nullptr);
     indexIVF_stats.quantization_time += getmillisecs() - t0;
 
     t0 = getmillisecs();
     invlists->prefetch_lists(idx.get(), n * nprobe_2);
 
     search_preassigned(
-            n, x, k, idx.get(), coarse_dis.get(), distances, labels, false);
+            n,
+            x,
+            k,
+            idx.get(),
+            coarse_dis.get(),
+            distances, labels,
+            false,
+            params);
     indexIVF_stats.search_time += getmillisecs() - t0;
 }
 
-- 
2.39.5 (Apple Git-154)

