From 379afe61155bac7f46aa332c00e67d31edb256d6 Mon Sep 17 00:00:00 2001
From: AnnTian Shao <anntians@amazon.com>
Date: Fri, 1 Aug 2025 18:04:23 -0700
Subject: [PATCH] Add multi-vector-support faiss patch to
 IndexHNSW::search_level_0

Signed-off-by: AnnTian Shao <anntians@amazon.com>
---
 faiss/IndexHNSW.cpp     | 117 ++++++++++++++++++++++++++++++----------
 faiss/index_factory.cpp |   7 ++-
 2 files changed, 94 insertions(+), 30 deletions(-)

diff --git a/faiss/IndexHNSW.cpp b/faiss/IndexHNSW.cpp
index 0f912b003..5cf1b0cdb 100644
--- a/faiss/IndexHNSW.cpp
+++ b/faiss/IndexHNSW.cpp
@@ -294,6 +294,61 @@ void hnsw_search(
     hnsw_stats.combine({n1, n2, ndis, nhops});
 }
 
+template <class BlockResultHandler>
+void hnsw_search_level_0(
+        const IndexHNSW* index,
+        idx_t n,
+        const float* x,
+        idx_t k,
+        const storage_idx_t* nearest,
+        const float* nearest_d,
+        float* distances,
+        idx_t* labels,
+        int nprobe,
+        int search_type,
+        const SearchParameters* params_in,
+        BlockResultHandler& bres) {
+
+    const HNSW& hnsw = index->hnsw;
+    const SearchParametersHNSW* params = nullptr;
+
+    if (params_in) {
+        params = dynamic_cast<const SearchParametersHNSW*>(params_in);
+        FAISS_THROW_IF_NOT_MSG(params, "params type invalid");
+    }
+
+#pragma omp parallel
+    {
+        std::unique_ptr<DistanceComputer> qdis(
+                storage_distance_computer(index->storage));
+        HNSWStats search_stats;
+        VisitedTable vt(index->ntotal);
+        typename BlockResultHandler::SingleResultHandler res(bres);
+
+#pragma omp for
+        for (idx_t i = 0; i < n; i++) {
+            res.begin(i);
+            qdis->set_query(x + i * index->d);
+
+            hnsw.search_level_0(
+                    *qdis.get(),
+                    res,
+                    nprobe,
+                    nearest + i * nprobe,
+                    nearest_d + i * nprobe,
+                    search_type,
+                    search_stats,
+                    vt,
+                    params);
+            res.end();
+            vt.advance();
+        }
+#pragma omp critical
+        { hnsw_stats.combine(search_stats); }
+    }
+
+}
+
 } // anonymous namespace
 
 void IndexHNSW::search(
@@ -446,38 +501,42 @@ void IndexHNSW::search_level_0(
 
     storage_idx_t ntotal = hnsw.levels.size();
 
-    using RH = HeapBlockResultHandler<HNSW::C>;
-    RH bres(n, distances, labels, k);
-
-#pragma omp parallel
-    {
-        std::unique_ptr<DistanceComputer> qdis(
-                storage_distance_computer(storage));
-        HNSWStats search_stats;
-        VisitedTable vt(ntotal);
-        RH::SingleResultHandler res(bres);
+    if (params && params->grp) {
+        using RH = GroupedHeapBlockResultHandler<HNSW::C>;
+        RH bres(n, distances, labels, k, params->grp);
 
-#pragma omp for
-        for (idx_t i = 0; i < n; i++) {
-            res.begin(i);
-            qdis->set_query(x + i * d);
+        hnsw_search_level_0(
+                this,
+                n,
+                x,
+                k,
+                nearest,
+                nearest_d,
+                distances,
+                labels,
+                nprobe, // n_probes
+                search_type, // search_type
+                params,
+                bres);
+    } else {
+        using RH = HeapBlockResultHandler<HNSW::C>;
+        RH bres(n, distances, labels, k);  
 
-            hnsw.search_level_0(
-                    *qdis.get(),
-                    res,
-                    nprobe,
-                    nearest + i * nprobe,
-                    nearest_d + i * nprobe,
-                    search_type,
-                    search_stats,
-                    vt,
-                    params);
-            res.end();
-            vt.advance();
-        }
-#pragma omp critical
-        { hnsw_stats.combine(search_stats); }
+        hnsw_search_level_0(
+                this,
+                n,
+                x,
+                k,
+                nearest,
+                nearest_d,
+                distances,
+                labels,
+                nprobe, // n_probes
+                search_type, // search_type
+                params,
+                bres);
     }
+
     if (is_similarity_metric(this->metric_type)) {
 // we need to revert the negated distances
 #pragma omp parallel for
diff --git a/faiss/index_factory.cpp b/faiss/index_factory.cpp
index baf7a760f..9b59b7a55 100644
--- a/faiss/index_factory.cpp
+++ b/faiss/index_factory.cpp
@@ -467,6 +467,11 @@ IndexHNSW* parse_IndexHNSW(
         return re_match(code_string, pattern, sm);
     };
 
+    if (match("Cagra")) {
+        IndexHNSWCagra* cagra = new IndexHNSWCagra(d, hnsw_M, mt);
+        return cagra;
+    }
+
     if (match("Flat|")) {
         return new IndexHNSWFlat(d, hnsw_M, mt);
     }
@@ -801,7 +806,7 @@ std::unique_ptr<Index> index_factory_sub(
 
     // HNSW variants (it was unclear in the old version that the separator was a
     // "," so we support both "_" and ",")
-    if (re_match(description, "HNSW([0-9]*)([,_].*)?", sm)) {
+    if (re_match(description, "HNSW([0-9]*)([,_].*)?(Cagra)?", sm)) {
         int hnsw_M = mres_to_int(sm[1], 32);
         // We also accept empty code string (synonym of Flat)
         std::string code_string =
-- 
2.39.5 (Apple Git-154)

